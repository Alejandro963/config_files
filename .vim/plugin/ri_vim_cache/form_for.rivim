= form_for

(from gem haml-3.1.7)
=== Implementation from ActionView::Helpers::FormHelper
------------------------------------------------------------------------------
  form_for(*args, &block)

------------------------------------------------------------------------------


(from gem actionpack-3.2.9)
=== Implementation from ActionView::Helpers::FormHelper
------------------------------------------------------------------------------
  form_for(record, options = {}, &proc)

------------------------------------------------------------------------------

Creates a form and a scope around a specific model object that is used as a
base for questioning about values for the fields.

Rails provides succinct resource-oriented form generation with
<tt>form_for</tt> like this:

  <%= form_for @offer do |f| %>
    <%= f.label :version, 'Version' %>:
    <%= f.text_field :version %><br />
    <%= f.label :author, 'Author' %>:
    <%= f.text_field :author %><br />
    <%= f.submit %>
  <% end %>

There, <tt>form_for</tt> is able to generate the rest of RESTful form
parameters based on introspection on the record, but to understand what it
does we need to dig first into the alternative generic usage it is based upon.

=== Generic form_for

The generic way to call <tt>form_for</tt> yields a form builder around a
model:

  <%= form_for :person do |f| %>
    First name: <%= f.text_field :first_name %><br />
    Last name : <%= f.text_field :last_name %><br />
    Biography : <%= f.text_area :biography %><br />
    Admin?    : <%= f.check_box :admin %><br />
    <%= f.submit %>
  <% end %>

There, the argument is a symbol or string with the name of the object the form
is about.

The form builder acts as a regular form helper that somehow carries the model.
Thus, the idea is that

  <%= f.text_field :first_name %>

gets expanded to

  <%= text_field :person, :first_name %>

The rightmost argument to <tt>form_for</tt> is an optional hash of options:

* <tt>:url</tt> - The URL the form is submitted to. It takes the same fields
  you pass to <tt>url_for</tt> or <tt>link_to</tt>. In particular you may pass
  here a named route directly as well. Defaults to the current action.
* <tt>:namespace</tt> - A namespace for your form to ensure uniqueness of id
  attributes on form elements. The namespace attribute will be prefixed with
  underscore on the generated HTML id.
* <tt>:html</tt> - Optional HTML attributes for the form tag.

Also note that <tt>form_for</tt> doesn't create an exclusive scope. It's still
possible to use both the stand-alone FormHelper methods and methods from
FormTagHelper. For example:

  <%= form_for @person do |f| %>
    First name: <%= f.text_field :first_name %>
    Last name : <%= f.text_field :last_name %>
    Biography : <%= text_area :person, :biography %>
    Admin?    : <%= check_box_tag "person[admin]", @person.company.admin? %>
    <%= f.submit %>
  <% end %>

This also works for the methods in FormOptionHelper and DateHelper that are
designed to work with an object as base, like
FormOptionHelper#collection_select and DateHelper#datetime_select.

=== Resource-oriented style

As we said above, in addition to manually configuring the <tt>form_for</tt>
call, you can rely on automated resource identification, which will use the
conventions and named routes of that approach. This is the preferred way to
use <tt>form_for</tt> nowadays.

For example, if <tt>@post</tt> is an existing record you want to edit

  <%= form_for @post do |f| %>
    ...
  <% end %>

is equivalent to something like:

  <%= form_for @post, :as => :post, :url => post_path(@post), :method => :put, :html => { :class => "edit_post", :id => "edit_post_45" } do |f| %>
    ...
  <% end %>

And for new records

  <%= form_for(Post.new) do |f| %>
    ...
  <% end %>

is equivalent to something like:

  <%= form_for @post, :as => :post, :url => posts_path, :html => { :class => "new_post", :id => "new_post" } do |f| %>
    ...
  <% end %>

You can also overwrite the individual conventions, like this:

  <%= form_for(@post, :url => super_posts_path) do |f| %>
    ...
  <% end %>

You can also set the answer format, like this:

  <%= form_for(@post, :format => :json) do |f| %>
    ...
  <% end %>

If you have an object that needs to be represented as a different parameter,
like a Person that acts as a Client:

  <%= form_for(@person, :as => :client) do |f| %>
    ...
  <% end %>

For namespaced routes, like <tt>admin_post_url</tt>:

  <%= form_for([:admin, @post]) do |f| %>
   ...
  <% end %>

If your resource has associations defined, for example, you want to add
comments to the document given that the routes are set correctly:

  <%= form_for([@document, @comment]) do |f| %>
   ...
  <% end %>

Where <tt>@document = Document.find(params[:id])</tt> and <tt>@comment =
Comment.new</tt>.

=== Setting the method

You can force the form to use the full array of HTTP verbs by setting

  :method => (:get|:post|:put|:delete)

in the options hash. If the verb is not GET or POST, which are natively
supported by HTML forms, the form will be set to POST and a hidden input
called _method will carry the intended verb for the server to interpret.

=== Unobtrusive JavaScript

Specifying:

  :remote => true

in the options hash creates a form that will allow the unobtrusive JavaScript
drivers to modify its behavior. The expected default behavior is an
XMLHttpRequest in the background instead of the regular POST arrangement, but
ultimately the behavior is the choice of the JavaScript driver implementor.
Even though it's using JavaScript to serialize the form elements, the form
submission will work just like a regular submission as viewed by the receiving
side (all elements available in <tt>params</tt>).

Example:

  <%= form_for(@post, :remote => true) do |f| %>
    ...
  <% end %>

The HTML generated for this would be:

  <form action='http://www.example.com' method='post' data-remote='true'>
    <div style='margin:0;padding:0;display:inline'>
      <input name='_method' type='hidden' value='put' />
    </div>
    ...
  </form>

=== Removing hidden model id's

The form_for method automatically includes the model id as a hidden field in
the form. This is used to maintain the correlation between the form data and
its associated model. Some ORM systems do not use IDs on nested models so in
this case you want to be able to disable the hidden id.

In the following example the Post model has many Comments stored within it in
a NoSQL database, thus there is no primary key for comments.

Example:

  <%= form_for(@post) do |f| %>
    <% f.fields_for(:comments, :include_id => false) do |cf| %>
      ...
    <% end %>
  <% end %>

=== Customized form builders

You can also build forms using a customized FormBuilder class. Subclass
FormBuilder and override or define some more helpers, then use your custom
builder. For example, let's say you made a helper to automatically add labels
to form inputs.

  <%= form_for @person, :url => { :action => "create" }, :builder => LabellingFormBuilder do |f| %>
    <%= f.text_field :first_name %>
    <%= f.text_field :last_name %>
    <%= f.text_area :biography %>
    <%= f.check_box :admin %>
    <%= f.submit %>
  <% end %>

In this case, if you use this:

  <%= render f %>

The rendered template is <tt>people/_labelling_form</tt> and the local
variable referencing the form builder is called <tt>labelling_form</tt>.

The custom FormBuilder class is automatically merged with the options of a
nested fields_for call, unless it's explicitly set.

In many cases you will want to wrap the above in another helper, so you could
do something like the following:

  def labelled_form_for(record_or_name_or_array, *args, &proc)
    options = args.extract_options!
    form_for(record_or_name_or_array, *(args << options.merge(:builder => LabellingFormBuilder)), &proc)
  end

If you don't need to attach a form to a model instance, then check out
FormTagHelper#form_tag.

=== Form to external resources

When you build forms to external resources sometimes you need to set an
authenticity token or just render a form without it, for example when you
submit data to a payment gateway number and types of fields could be limited.

To set an authenticity token you need to pass an <tt>:authenticity_token</tt>
parameter

  <%= form_for @invoice, :url => external_url, :authenticity_token => 'external_token' do |f|
    ...
  <% end %>

If you don't want to an authenticity token field be rendered at all just pass
<tt>false</tt>:

  <%= form_for @invoice, :url => external_url, :authenticity_token => false do |f|
    ...
  <% end %>


